## 题目链接

https://leetcode-cn.com/problems/game-of-life/

## 题目描述

```
给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：
	1.如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
	2.如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
	3.如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
	4.如果死细胞周围正好有三个活细胞，则该位置死细胞复活；
根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。

示例：

输入： 
[
  [0,1,0],
  [0,0,1],
  [1,1,1],
  [0,0,0]
]
输出：
[
  [0,0,0],
  [1,0,1],
  [0,1,1],
  [0,1,0]
]
 

进阶：
	你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。
	本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？
```

## 思路

1. 遍历borad中的细胞
2. 统计每个细胞周围活细胞的数量.这里采用创建方向数组可以将八个方向遍历到
3. 计算该细胞新一轮的细胞状态,这里会用能同时表达过去状态和现在状态的复合状态
   * 规则 1：如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡。这时候，将细胞值改为 `-1`，代表这个细胞过去是活的现在死了
   * 规则 2：如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活。这时候不改变细胞的值，仍为 `1`
   * 规则 3：如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡。这时候，将细胞的值改为 -1，代表这个细胞过去是活的现在死了。可以看到，因为规则 1 和规则 3 下细胞的起始终止状态是一致的，因此它们的复合状态也一致

   * 规则 4：如果死细胞周围正好有三个活细胞，则该位置死细胞复活。这时候，将细胞的值改为 `2`，代表这个细胞过去是死的现在活了
4. 更新数组

## 代码

```Java
class Solution {
    public void gameOfLife(int[][] board) {

        int[] neighbors = {-1,0,1};

        int rows = board.length;
        int cols = board[0].length;
        for (int row=0;row<rows;row++)
        {
            for (int col = 0;col<cols;col++)
            {
                int liveNeighbors = 0;

                for (int i=0;i<3;i++)
                {
                    for (int j=0;j<3;j++)
                    {
                        if (!(neighbors[i] == 0 && neighbors[j] == 0))
                        {
                            int r = row+neighbors[i];
                            int c = col+neighbors[j];
                            if ((r<rows && r>=0) && (c<cols && c>=0) && (Math.abs(board[r][c])==1))
                                liveNeighbors++;
                        }
                    }
                }
                
                if ((board[row][col] == 1) && (liveNeighbors<2 || liveNeighbors>3))
                {
                    board[row][col] = -1;
                }

                if (board[row][col] == 0 && liveNeighbors == 3)
                {
                    board[row][col] = 2;
                }
            }
        }

        for (int row = 0;row<rows;row++)
        {
            for (int col=0;col<cols;col++)
            {
                if (board[row][col]>0)
                    board[row][col]=1;
                else
                    board[row][col]=0;
            }
        }
    }
}
```

